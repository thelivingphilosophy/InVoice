import AsyncStorage from '@react-native-async-storage/async-storage';
import { JobData, JobWorkflow } from '@/types/job';

export class JobStorageService {
  private static readonly JOBS_KEY = 'saved_jobs';
  private static readonly WORKFLOW_KEY = 'active_workflow';

  async saveJob(job: JobData): Promise<void> {
    try {
      const existingJobs = await this.getAllJobs();
      const jobIndex = existingJobs.findIndex(j => j.id === job.id);
      
      if (jobIndex >= 0) {
        existingJobs[jobIndex] = job;
      } else {
        existingJobs.push(job);
      }
      
      await AsyncStorage.setItem(JobStorageService.JOBS_KEY, JSON.stringify(existingJobs));
      console.log('üíæ Job saved successfully:', job.id);
    } catch (error) {
      console.error('‚ùå Failed to save job:', error);
      throw error;
    }
  }

  async getAllJobs(): Promise<JobData[]> {
    try {
      const stored = await AsyncStorage.getItem(JobStorageService.JOBS_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('‚ùå Failed to load jobs:', error);
      return [];
    }
  }

  async getJobById(id: string): Promise<JobData | null> {
    try {
      const jobs = await this.getAllJobs();
      return jobs.find(job => job.id === id) || null;
    } catch (error) {
      console.error('‚ùå Failed to get job by ID:', error);
      return null;
    }
  }

  async deleteJob(id: string): Promise<void> {
    try {
      const jobs = await this.getAllJobs();
      const filteredJobs = jobs.filter(job => job.id !== id);
      await AsyncStorage.setItem(JobStorageService.JOBS_KEY, JSON.stringify(filteredJobs));
      console.log('üóëÔ∏è Job deleted successfully:', id);
    } catch (error) {
      console.error('‚ùå Failed to delete job:', error);
      throw error;
    }
  }

  async saveWorkflow(workflow: JobWorkflow): Promise<void> {
    try {
      await AsyncStorage.setItem(JobStorageService.WORKFLOW_KEY, JSON.stringify(workflow));
      console.log('üíæ Workflow saved successfully:', workflow.id);
    } catch (error) {
      console.error('‚ùå Failed to save workflow:', error);
      throw error;
    }
  }

  async getActiveWorkflow(): Promise<JobWorkflow | null> {
    try {
      const stored = await AsyncStorage.getItem(JobStorageService.WORKFLOW_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      console.error('‚ùå Failed to load workflow:', error);
      return null;
    }
  }

  async deleteAllWorkflows(): Promise<void> {
    try {
      await AsyncStorage.removeItem(JobStorageService.WORKFLOW_KEY);
      console.log('üóëÔ∏è All workflows deleted');
    } catch (error) {
      console.error('‚ùå Failed to delete workflows:', error);
      throw error;
    }
  }

  formatJobForEmail(job: JobData): string {
    return `
JOB SUMMARY
===========

Customer: ${job.customer || 'Not specified'}
Job Type: ${job.jobType || 'Not specified'}
Equipment/Materials: ${job.equipment || 'Not specified'}
Cost: ${job.cost || 'Not specified'}
Location: ${job.location || 'Not specified'}

Additional Notes:
${job.additionalNotes || 'None'}

Job Details:
- Status: ${job.status}
- Created: ${new Date(job.dateCreated).toLocaleDateString()}
- Completed: ${job.dateCompleted ? new Date(job.dateCompleted).toLocaleDateString() : 'Pending'}
- Progress: ${job.completedSteps}/${job.totalSteps} steps

Generated by Tradesman Voice Assistant
    `.trim();
  }
}